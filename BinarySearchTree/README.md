# Реализация фундаментальной структуры данных - двоичного дерева поиска.

![двоичное дерево поиска](https://github.com/user-attachments/assets/896d0307-9456-4a2c-8f3c-68e19be2d68f)

## Содержание:

- [Описание проекта:](#описание-проекта)
- [Некоторые особенности:](#некоторые-особенности)
- [Предоставляемый функционал:](#предоставляемый-функционал)
  - [Итераторы:](#итераторы)
  - [Изменение дерева:](#изменение-дерева)
  - [Информация о дереве:](#информация-о-дереве)
  - [Поиск в дереве:](#поиск-в-дереве)
  - [Обход дерева:](#обход-дерева)
- [Примеры использования:](#примеры-использования)
- [Лицензия:](#лицензия)
- [Автор:](#автор)

## Описание проекта:

Данный проект содержит реализацию двоичного дерева поиска на языке программирования C++. Класс *BinarySearchTree* представляет собой двоичное дерево поиска и включает все основные операции, необходимые для эффективной работы с деревом:

1) `ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ В ДЕРЕВО:` *добавление элементов в дерево ( позиция вставки выбирается автоматически ).*
2) `УДАЛЕНИЕ ЭЛЕМЕНТОВ ИЗ ДЕРЕВА:` *полная очистка дерева.*
3) `ПРОВЕРКА НАЛИЧИЯ ЭЛЕМЕНТА В ДЕРЕВЕ:` *определение, содержится ли некоторый элемент в дереве.*
4) `РЕКОНСТРУКЦИЯ ДЕРЕВА:` *реконструкция дерева в случае его неправильной структуры или сильной несбалансированности.*
5) `ДОСТУП К ЭЛЕМЕНТАМ ДЕРЕВА:` *получение значений минимального и максимального элементов дерева.*
6) `ИНФОРМАЦИЯ О ДЕРЕВЕ:` *получение длины и высоты дерева, суммы всех элементов, проверка дерева на пустоту.*
7) `ПРЕОБРАЗОВАНИЕ К ВЕКТОРУ:` *преобразование дерева к std::vector.*

- Кроме того, в классе *BinarySearchTree* реализован итератор ( *std::forward_iterator_tag* ), позволяющий работать с данным контейнером через STL, что облегчает жизнь пользователю. Реализованы все необходимые конструкторы, обеспечено грамотное управление всеми ресурсами и строгое соблюдение принципов инкапсуляции. Также перегружены все необходимые операторы для удобства и эффективности использования класса.

## Некоторые особенности:

### Класс *BinarySearchTree:*
1) Находится в пространстве имен *Containers*.
2) Является **шаблонным**, что позволяет пользователю работать с различными типами данных.

## Предоставляемый функционал:

### *Итераторы:*
- ```begin()``` -> возвращает итератор на наименьший элемент дерева.
- ```end()``` -> возвращает итератор на элемент, следующий за наибольшим элементом дерева.

### *Изменение дерева:*
- ```push(const T& value)``` -> добавляет элемент в дерево.
- ```reconstruct()``` -> реконструирует дерево ( в случае его неверной структуры / плохой сбалансированности ). 
- ```clear()``` -> полностью очищает дерево.

### *Информация о дереве:*
- ```isEmpty()``` -> проверяет, пустое ли дерево. Возвращает соответствующее булевое значение.
- ```height()``` -> возвращает текущую высоту дерева.
- ```size()``` -> возвращает количество узлов в дереве.

### *Поиск в дереве:*
- ```contains(const T& value)``` -> проверяет наличие элемента в дереве. Возвращает соответствующее булевое значение.
- ```min()``` -> находит минимальный элемент в дереве и возвращает его значение.
- ```max()``` -> находит максимальный элемент в дереве и возвращает его значение.

### *Обход дерева:*
- ```print()``` -> выводит элементы дерева в консоль ( в порядке возрастания значений ).
- ```toVector()``` -> возвращает вектор, содержащий все элементы дерева ( в порядке возрастания значений ). 
- ```sum()``` -> суммирует значения всех элементов. Возвращает результирующее значение.

## Примеры использования:

### *Итераторы:*
```
    // Создаем бинарное дерево поиска.
    Containers::BinarySearchTree<int> tree{ 0, 1, 2, 3, 4, 5 };

    // Умножаем каждый элемент дерева на 2 с помощью std::for_each.
    std::for_each(tree.begin(), tree.end(), [](int& n) { n *= 2; });

    // Выводим все элементы дерева на экран с помощью цикла range-based for ( который основан на итераторах ).
    for (int value: tree) { std::cout << value << ' '; } // 0 2 4 6 8 10
```

### *Изменение дерева:*
```
    // 1. Создаем бинарное дерево поиска.
    Containers::BinarySearchTree<int> tree;
    // 1.1 Добавляем элементы в дерево.
    for (int value: {5, 1, 0, 7, 2, 8, 3, 9, 4, 6}) { tree.push(value); }
    // 1.2 Выводим элементы в консоль:
    tree.print(); // 0 1 2 3 4 5 6 7 8 9


    // 2. Нарушаем структуру дерева:
    std::for_each(tree.begin(), tree.end(), [](int& n) { if (n % 2) { n *= -1; } });
    // 2.1 Выводим элементы в консоль:
    tree.print(); // 0 -1 2 -3 4 -5 6 -7 8 -9


    // 3. Реконструируем дерево, чтобы вернуть ему правильную структуру.
    tree.reconstruct();
    // 3.1 Выводим элементы в консоль:
    tree.print(); // -9 -7 -5 -3 -1 0 2 4 6 8


    // 4. Очищаем дерево:
    tree.clear();
    // 4.1 Выводим элементы в консоль:
    tree.print(); // Пусто.
```

### *Информация о дереве:*
```
    // 1. Создаем бинарное дерево поиска.
    Containers::BinarySearchTree<int> tree{5, 3, 7, 1, 2, 8, 9, 4, 6};

    // 2. Проверяем, не пустое ли дерево:
    if (!tree.isEmpty()) {
        std::cout << "Yep!\n";
    }  // Вывод: Yep!

    // 3. Выводим в консоль высоту дерева:
    std::cout << tree.height(); // 4

    // 4. Выводим в консоль количество элементов в дереве: 
    std::cout << tree.size(); // 9
```

### *Поиск в дереве:*
```
    // 1. Создаем бинарное дерево поиска.
    Containers::BinarySearchTree<int> tree{5, 3, 7, 1, 2, 8, 9, 4, 6};

    // 2. Проверяем, содержит ли дерево '8':
    if (tree.contains(8)) {
        std::cout << "Yep!\n";
    } // Вывод: Yep!

    // 3. Выводим в консоль минимальный элемент дерева:
    std::cout << tree.min(); // 1

    // 4. Выводим в консоль максимальный элемент дерева:
    std::cout << tree.max(); // 9
```

### *Обход дерева:*
```
    // 1. Создаем бинарное дерево поиска.
    Containers::BinarySearchTree<int> tree{5, 3, 7, 1, 2, 8, 9, 4, 6};

    // 2. Выводим все элементы дерева в консоль: 
    tree.print(); // 1 2 3 4 5 6 7 8 9

    // 3. Инициализируем вектор helper значениями из tree.
    std::vector<int> helper{ tree.toVector() };
    // 3.1 Выводим все элементы вектора в консоль:
    for (int value: helper) { std::cout << value << ' '; } // 1 2 3 4 5 6 7 8 9

    // 4. Выводим в консоль сумму всех элементов дерева.
    std::cout << tree.sum(); // 45
```

## Лицензия:

- Этот проект распространяется под лицензией MIT — подробности см. в файле [LICENSE](LICENSE).

## Автор:

**Юрий Давыденко** ( *junior C++ developer* ).

- GitHub: [github.com/shakrovsky](https://github.com/shakrovsky)
- Telegram: [https://t.me/tailung_official](https://t.me/tailung_official)
